### **1. Перегляд та аналіз схеми**

Більшість таблиць (User, Category, Cart, Review) мають чітку структуру, проте, є 2 таблиці, які мають структурні недоліки: Address та Discount.

**Таблиця 1: Address**

- Поточна структура:
  address_id, user_id, country, city, street, postal_code, is_default.
- Проблема: надмірність. У багатьох системах postal_code визначає місто та країну. Зберігання міста та країни для кожної адреси з однаковим postal_code створює дублювання даних.
- Порушення: 3NF (транзитивна залежність).

**Таблиця 2: Знижка**

- Поточна структура: discount_id, code, type, value, valid_from, valid_to, product_id, order_id.
- Проблема: ця таблиця змішує визначення знижки з її застосуванням.
  - Якщо застосовується код до 50 різних замовлень (пов'язаних через order_id), то ми повинні створити 50 рядків у цій таблиці.
  - У цих 50 рядках значення, тип і дати є ідентичними.
  - Якщо значення знижки змінюється, ми стикаємося з аномалією оновлення (треба оновити всі 50 рядків).
- Порушення: 3NF (транзитивна залежність).

---

### **2. Функціональні залежності та нормалізація**

Нормалізація адреси
Функціональні залежності:

- address_id → user_id, street, postal_code, is_default
- postal_code → city, country

**Покрокова нормалізація:**

- 1NF (атомарні значення): таблиця вже відповідає 1NF. Усі поля є атомарними рядками/цілими числами.
- 2NF (часткові залежності): первинним ключем (PK) є address_id (один стовпець). Тому часткові залежності неможливі. Таблиця відповідає 2NF.
- 3NF (транзитивні залежності):
  - Поточний ланцюжок: address_id → postal_code → city, country
  - Аналіз: місто та країна залежать від postal_code, який не є первинним ключем.
  - Виправлення: Розкласти на дві таблиці: PostalRegion (пошук) та Address (посилання на пошук).

Нормалізація знижки
Функціональні залежності (FD):

1. discount_id → code, order_id, value, type, dates
2. code → value, type, valid_from, valid_to

Покрокова нормалізація:

- 1NF: Атомарні атрибути. Виконано.
- 2NF: PK — discount_id. Виконано.
- 3NF (Транзитивні залежності):
  - discount_id → code → value
  - value залежить від code, value не повинно повторюватися для кожного запису order_id або product_id.
  - Виправлення: розділити таблицю на DiscountRule і правильно пов'язати її в таблицях Order або Product за допомогою зовнішнього ключа, а не вбудовувати дані використання в таблицю визначень.

### **3. Перероблена схема SQL**

У `corrected_database_structure.sql` надано фінальні версії таблиць, що буде взято за основу для виконання 6 лабораторної роботи "Schema Migrations with Prisma ORM"
